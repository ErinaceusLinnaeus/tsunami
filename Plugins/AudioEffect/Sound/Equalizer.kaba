// Image = hui:properties
// Title[Deutsch] = Equalizer

use "../../api.kaba"
use "../../grid.kaba"
use "../../tone.kaba"



const float MIN_FREQ = 20.0
const float MAX_FREQ = 20000.0
const int MIN_VOL = 0-55
const int MAX_VOL = 35

class Filter
	float[3] a, b
	float sample_rate
	void apply(float[] x, float[] y, float[2] prev_x, float[2] prev_y)
		// overlap
		y[0] = b[0] * x[0] + b[1] * prev_x[1] + b[2] * prev_x[0] - a[1] * prev_y[1] - a[2] * prev_y[0]
		y[1] = b[0] * x[1] + b[1] * x[0]      + b[2] * prev_x[1] - a[1] * y[0]      - a[2] * prev_y[1]
		// main chunk
		for i in 2:x.num
			y[i] = b[0] * x[i] + b[1] * x[i-1] + b[2] * x[i-2] - a[1] * y[i-1] - a[2] * y[i-2]
	void __init__()
		a[0] = 0
		a[1] = 0
		a[2] = 0
		b[0] = 1
		b[1] = 0
		b[2] = 0
	void __assign__(Filter o)
	float gain(float f)
		complex z
		z.x = cos(2*pi*f/sample_rate)
		z.y = sin(2*pi*f/sample_rate)
		complex H = complex(b[0], 0) + b[1]*z + b[2]*z*z
		complex y = complex(1,0) + a[1]*z + a[2]*z*z
		
		float fac = H.abs() / y.abs()
		return factor_to_db(fac)

	void create_peak(float f_res, float Q, float g)
		float c = 1 / tan(pi * f_res / sample_rate)
		float B = 1 / Q
		float a0 = c*c + B*c + 1
		b[0] = (c*c + B*c*g + 1) / a0
		a[1] = (2 - 2*c*c) / a0
		b[1] = a[1]
		a[2] = (c*c - B*c + 1) / a0
		b[2] = (c*c - B*g*c + 1) / a0

	void create_low_pass(float f_res)
		b[0] = 1 / (1 + sample_rate/f_res/2/pi)
		b[1] = 0
		b[2] = 0
		a[1] = b[0]-1
		a[2] = 0

	void create_high_pass(float f_res)
		b[0] = 1 / (1 + f_res*2*pi / sample_rate)
		b[1] = -b[0]
		b[2] = 0
		a[1] = -b[0]
		a[2] = 0

	void create_low_shelf(float f_res, float q, float gain)
		float V = db_to_factor(abs(gain))
		float c = tan(pi * f_res / sample_rate)
		
		if gain > 0
			float a0 = 1 + sqrt(2)*c + c*c
			b[0] = (1 + sqrt(2*V)*c + V*c*c) / a0
			b[1] = 2*(V*c*c - 1) / a0
			b[2] = (1-sqrt(2*V)*c + V*c*c) / a0
			a[1] = 2*(c*c - 1) / a0
			a[2] = (1-sqrt(2)*c + c*c) / a0
		else
			float a0 = 1 + sqrt(2*V)*c + V*c*c
			b[0] = (1 + sqrt(2)*c + c*c) / a0
			b[1] = 2*(c*c - 1) / a0
			b[2] = (1 - sqrt(2)*c + c*c) / a0
			a[1] = 2*(V*c*c - 1) / a0
			a[2] = (1 - sqrt(2*V)*c + V*c*c) / a0
		
		/*float c = 2 * sample_rate//1 / tan(pi * f_res / sample_rate)
		float w = 2*pi*f_res
		float ww = w * (B+1)
		float a0 = w+ww
		b[0] = (c+ww) / a0
		b[1] = (ww-c) / a0
		b[2] = 0
		a[1] = (w-c) / a0
		a[2] = 0*/

	void create_high_shelf(float f_res, float q, float gain)
		float V = db_to_factor(abs(gain))
		float c = tan(pi * f_res / sample_rate)
		
		if gain > 0
			float a0 = 1 + sqrt(2)*c + c*c
			b[0] = (V + sqrt(2*V)*c + c*c) / a0
			b[1] = 2*(c*c - V) / a0
			b[2] = (V - sqrt(2*V)*c + c*c) / a0
			a[1] = 2*(c*c - 1) / a0
			a[2] = (1 - sqrt(2)*c + c*c) / a0
		else
			float a0 = V + sqrt(2*V)*c + c*c
			b[0] = (1 + sqrt(2)*c + c*c) / a0
			b[1] = 2*(c*c - 1) / a0
			b[2] = (1 - sqrt(2)*c + c*c) / a0
			a[1] = 2*(c*c - V) / a0
			a[2] = (V - sqrt(2*V)*c + c*c) / a0

enum
	POINT_PEAK
	POINT_LOW_PASS
	POINT_HIGH_PASS
	POINT_LOW_SHELF
	POINT_HIGH_SHELF

class Peak
	bool enabled
	int mode
	float pitch
	float gain
	float q
	complex z(float g0)
		complex r
		r.x = pitch_to_freq(pitch)
		r.y = gain + g0
		return r
	//float q()
		// ~ (f1 - f0) / f0 = f1/f0 - 1
	//	return pow(2, width/12) - 1
	
	void create_filter(Filter f, float sample_rate)
		f.sample_rate = sample_rate
		if mode == POINT_LOW_PASS
			f.create_low_pass(pitch_to_freq(pitch))
		else if mode == POINT_HIGH_PASS
			f.create_high_pass(pitch_to_freq(pitch))
		else if mode == POINT_PEAK
			f.create_peak(pitch_to_freq(pitch), q, db_to_factor(gain))
		else if mode == POINT_LOW_SHELF
			f.create_low_shelf(pitch_to_freq(pitch), q, gain)
		else if mode == POINT_HIGH_SHELF
			f.create_high_shelf(pitch_to_freq(pitch), q, gain)
				
	float dgain(float _pitch)
		if !enabled
			return 0
		float dpitch = _pitch-pitch
		float width = 20
		float d = dpitch / width
		if mode == POINT_PEAK
			return gain * exp(-d*d)
		if mode == POINT_LOW_PASS
			return - log(1 + exp( abs(gain)/12 * d))*width
		if mode == POINT_HIGH_PASS
			return - log(1 + exp(-abs(gain)/12 * d))*width
		if mode == POINT_LOW_SHELF
			return gain / (1+ exp(d))
		if mode == POINT_HIGH_SHELF
			return gain / (1+ exp(-d))
		return 0
Peak _Peak(int mode, float pitch, float gain, float q)
	Peak p
	p.enabled = true
	p.mode = mode
	p.pitch = pitch
	p.gain = gain
	p.q = q
	return p
				

class EqCurve extends Curve
	float gain
	Peak[] peaks
	float sample_rate
	void set(Config c, float _sample_rate)
		gain = c.gain
		peaks = c.peaks
		sample_rate = _sample_rate
	override float get(float freq)
		/*float pitch = freq_to_pitch(f)*/
		float r = gain
		for p in peaks
			if p.enabled
				Filter f
				p.create_filter(f, sample_rate)
				r += f.gain(freq)//p.dgain(pitch)
		return r

class Config extends PluginData
	float gain
	Peak[] peaks

	override void reset()
		gain = 0
		peaks.clear()
		peaks.add(_Peak(POINT_HIGH_PASS, 30, -10, 10))
		peaks.add(_Peak(POINT_LOW_PASS, 100, -10, 10))
		//for p in peaks
		//	p.enabled = false

const int MAX_PEAKS = 32

class Equalizer extends AudioEffect

	Config config
	float[2][MAX_PEAKS+1][2] overlap
	
	override void reset_state()
		for c in 0:2
			for p in 0:MAX_PEAKS+1
				for i in 0:2
					overlap[c][p][i] = 0

	void equalize(float[] buf, int channel)
		int num_stages = config.peaks.num
		for p,stage in config.peaks
			Filter f
			float[] input = buf
			
			p.create_filter(f, session.sample_rate())
			if p.enabled
				f.apply(input, buf, overlap[channel][stage], overlap[channel][stage+1])
			
			// save input overlap
			for i in 0:2
				overlap[channel][stage][i] = input[buf.num - 2 + i]
		// save output overlap
		for i in 0:2
			overlap[channel][num_stages][i] = buf[buf.num - 2 + i]

	override void process(AudioBuffer buf)
		equalize(buf.r, 0)
	//	if buf.channels > 1
	//		equalize(buf.l, 1)

	override ConfigPanel *create_panel()
		return new EqualizerPanel(self)


class EqualizerGrid extends Grid
	Config *c
	EqualizerPanel *cp
	float sample_rate
	int hover, selected
	override void __init__()
		hover = -1
		selected = -1
	override void on_draw(Painter *p)
		// curve + area below
		EqCurve curve
		curve.set(*c, sample_rate)
		draw_curve_c(p, curve, true)
		
		// gain base-line
		float y = y_axis.project(c.gain)
		p.set_line_width(2)
		p.set_color(colors.text_soft2)
		p.set_line_dash([8.0,5.0])
		p.draw_line(0,y, p.width,y)
		p.set_line_dash([8.0,0.0])
	
		// points
		for pk,i in c.peaks
			complex pp = project2(pk.z(c.gain))
			
			p.set_line_width(2)
			color col = point_color(i == selected, i == hover)
			color col2 = col
			col2.a = 0.6
			p.set_color(col2)
			p.draw_line(pp.x, 0, pp.x, p.height)
			
			p.set_font_size(12)
			draw_boxed_str(p, pp.x-5, 10, (i+1), col_text, colors.text_soft3)
			
			draw_point2(p, pk.z(c.gain), i == selected, i == hover)
			if i == hover
				p.set_font_size(8)
				p.set_color(col_hover)
				p.draw_str(pp.x - 20, pp.y - 50, pitch_to_freq(pk.pitch).str2(1) + " Hz")
				p.draw_str(pp.x - 20, pp.y - 35, pk.gain.str2(1) + " dB")
				p.draw_str(pp.x - 20, pp.y - 20, "Q " + pk.q.str2(1))
			

	// left button down -> select
	override void on_left_button_down()
		selected = hover
		redraw()

	override void on_mouse_wheel()
		if hover >= 0
			if HuiGetEvent().scroll_y > 0
				c.peaks[hover].q *= 1.04
			else
				c.peaks[hover].q /= 1.04
			cp.changed()
			redraw()

	// right button down -> new point
	override void on_right_button_down()
		vector m = get_mouse3(0)
		c.peaks.add(_Peak(POINT_PEAK, freq_to_pitch(m.x), m.y - c.gain, 10))
		selected = c.peaks.num - 1
		hover = selected
		cp.changed()
		redraw()

	override void on_mouse_move()
		// move
		if HuiGetEvent().button_l and (selected >= 0)
			c.peaks[selected].pitch = freq_to_pitch(get_mouse2().x)
			c.peaks[selected].gain = get_mouse2().y - c.gain
			/*float xmin = MIN_FREQ
			float xmax = MAX_FREQ
			if selected > 0
				xmin = c.curve[selected - 1].x
			if selected < c.curve.num - 1
				xmax = c.curve[selected + 1].x
			c.curve[selected].x = clamp(c.curve[selected].x, xmin, xmax)
			c.curve[selected].y = clamp(c.curve[selected].y, MIN_VOL, MAX_VOL)
			if selected == c.curve.num - 1
				c.curve[selected].x = MAX_FREQ
			if selected == 0
				c.curve[selected].x = MIN_FREQ*/
			cp.changed()
		else
		// mouse over?
			hover = -1
			for i in 0:c.peaks.num
				if mouse_over_point2(c.peaks[i].z(c.gain))
					hover = i
		redraw()

	// [Delete] -> remove point
	override void on_key_down()
		if HuiGetEvent().key_code == KEY_DELETE
			if selected >= 0
				c.peaks.remove(selected)
				cp.changed()
				selected = -1
				hover = -1
				redraw()

class EqualizerPanel extends ConfigPanel
	EqualizerGrid grid
	int num_peaks
	override void __init__(Equalizer *e)
		super.__init__(e)
		add_grid("", 0, 0, "grid")
		set_target("grid")
		add_drawing_area("!grabfocus,height=250", 0, 0, "drawing")
		add_grid("", 0, 1, "stuff")
		add_grid("", 0, 2, "peaks")
		set_target("stuff")
		add_label("!width=80\\Gain", 0, 0, "")
		add_spin_button("!range=-40:40:0.1,expandx", 1, 0, "gain")
		add_label("dB", 2, 0, "")
		hide_control("peaks", true)
	
		grid.init(self, "drawing")
		grid.x_axis.set(MIN_FREQ, MAX_FREQ, true, "Hz")
		grid.y_axis.set(MIN_VOL, MAX_VOL, false, "db")
		
		grid.cp = self
		grid.c = &e.config
		grid.sample_rate = e.session.sample_rate()
		num_peaks = 0
		
		event("*", &on_ui_change)
		
	void on_ui_change()
		string id = HuiGetEvent().id
		if id != "gain" and id.head(5) != "mode-" and id.head(8) != "enabled-"
			return
			
		grid.c.gain = get_float("gain")
		for pk,i in grid.c.peaks
			pk.mode = get_int("mode-" + i)
			pk.enabled = is_checked("enabled-" + i)
		//grid.redraw()
		changed()
		
	override void update()
		grid.redraw()
		set_float("gain", grid.c.gain)
		
		for i in num_peaks:grid.c.peaks.num
			set_target("peaks")
			add_grid("", i, 0, "peak-" + i)
			set_target("peak-" + i)
			add_check_box("" + (i+1), 0, 0, "enabled-" + i)
			add_combo_box("Peak\\Low pass\\High pass\\Low shelf\\High shelf", 0, 1, "mode-" + i)
			/*add_spin_button("!range=::0.1", 0, 2, "freq-" + i)
			add_spin_button("!range=::0.1", 0, 2, "gain-" + i)
			add_spin_button("!range=::0.001", 0, 2, "q-" + i)*/
			/*add_label("", 0, 2, "freq-" + i)
			add_label("", 0, 3, "gain-" + i)
			add_label("", 0, 4, "q-" + i)*/
		for i in grid.c.peaks.num:num_peaks
			delete_control("peak-" + i)
		num_peaks = grid.c.peaks.num
		
		for pk,i in grid.c.peaks
			check("enabled-" + i, pk.enabled)
			set_int("mode-" + i, pk.mode)
			/*set_float("freq-" + i, pk.freq)
			set_float("gain-" + i, pk.gain)
			set_float("q-" + i, pk.q)*/
			/*set_string("freq-" + i, pk.freq.str2(1) + " Hz")
			set_string("gain-" + i, pk.gain.str2(1) + " dB")
			set_string("q-" + i, "q: " + pk.q.str2(3))*/

	override void set_large(bool large)
		if large
			set_options("drawing", "height=380")
		else
			set_options("drawing", "height=250")
		hide_control("peaks", !large)

