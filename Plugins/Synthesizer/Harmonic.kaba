use "../api.kaba"
use "../tone.kaba"
use "../grid.kaba"

const int NUM_HARMONICS = 10

class PitchState
	float volume
	float phi
	EnvelopeADSR env

class HarmonicConfig extends PluginData
	float[NUM_HARMONICS] intensity
	float release
	override void reset()
		intensity[0] = 0.3
		intensity[1] = 0.1
		for i in 2:NUM_HARMONICS
			intensity[i] = 0
		release = 0.02

class HarmonicGrid extends Grid
	HarmonicConfig *hc
	HarmonicPanel *p
	int Selected, Hover

	override void on_draw(Painter *c)
	
		// points
		for i,n in hc.intensity
			complex z0 = complex(n+1, 0)
			complex z1 = complex(n+1, i)
			c.set_line_width(2)
			draw_line2(c, z0, z1, n == Selected, n == Hover)
			draw_point2(c, z1, n == Selected, n == Hover)
			
	// left button down -> select
	override void on_left_button_down()
		Selected = Hover
		redraw()

	override void on_mouse_move()
		// move
		if HuiGetEvent().button_l and (Selected >= 0)
			hc.intensity[Selected] = clamp(get_mouse2().y, 0, 1)
			p.changed()
		else
		// hover?
			Hover = -1
			for i,n in hc.intensity
				complex p = project2(complex(n+1, i))
				if (mx > p.x - 10) and (mx < p.x + 10)
					Hover = n
		redraw()

class HarmonicPanel extends ConfigPanel
	override HarmonicSynthesizer *c
	HarmonicConfig *hc
	HarmonicGrid grid
	override void __init__(HarmonicSynthesizer *_s)
		super.__init__(_s)
		add_grid("", 0, 0, "main_table")
		set_target("main_table")
		add_grid("", 0, 0, "table1")
		add_drawing_area("!grabfocus,width=400", 0, 1, "drawing")
		set_target("table1")
		add_label("Release", 0, 0, "")
		add_spin_button("!range=0:500:0.1\\0", 1, 0, "release")
		add_label("ms", 2, 0, "")
		event("release", &on_change)
		hc = &c.config
		
		grid.hc = hc
		grid.p = self
		grid.init(self, "drawing")
		grid.x_axis.set(0.5, NUM_HARMONICS + 0.5, false, "")
		grid.y_axis.set(0, 1.05, false, "")
		
	void on_change()
		hc.release = get_float("release") / 1000
		changed()
	
	override void update()
		redraw("drawing")
		set_float("release", hc.release * 1000)
		

class HarmonicSynthesizer extends Synthesizer
	HarmonicConfig config
	
	PitchState[MAX_PITCH] pitch
	override void reset_state()
		for p in pitch
			p.volume = 0
			p.phi = 0
			p.env.reset()

	override ConfigPanel *create_panel()
		return new HarmonicPanel(self)
	
	override void on_config()
		for p in pitch
			p.env.set(0.01, 0.01, 0.7, config.release, sample_rate)
		
	override void render(AudioBuffer buf)
		for i in 0:buf.length

			// current events?
			for e in events
				if e.pos == i
					int pp = e.pitch+0.4
					PitchState *s = &pitch[pp]
					if e.volume == 0
						s.env.end()
					else
						s.env.start(e.volume)
						enable_pitch(pp, true)

			for p in active_pitch
				PitchState *s = &pitch[p]

				s.volume = s.env.get()

				if s.volume == 0
					enable_pitch(p, false)
					continue

				float d = 0
				for j in 0:NUM_HARMONICS
					d += sin(s.phi * (j+1)) * config.intensity[j]
				buf.r[i] += d * s.volume

				s.phi += delta_phi[p]
				if s.phi > 8*pi
					s.phi = loop(s.phi, 0, 2*pi)
		
		if buf.channels > 1
			buf.l = buf.r
