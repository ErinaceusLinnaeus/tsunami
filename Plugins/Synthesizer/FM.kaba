use "../api.kaba"
use "../tone.kaba"

const int NUM_OSCILLATORS = 6

class OscillatorConfig
	float factor
	float amplitude
	float initial, peak, sustain
	float attack, decay, release

class OscillatorLink
	int source, dest

class FMConfig : PluginData
	OscillatorConfig[NUM_OSCILLATORS] osc
	OscillatorLink[] link
	overwrite void reset()
		link.clear()
		for int j, 0, NUM_OSCILLATORS
			osc[j].factor = 1
			osc[j].amplitude = 0
			osc[j].attack = 0.01
			osc[j].decay = 0.4
			osc[j].release = 0.4
			osc[j].initial = 0.01
			osc[j].peak = 1
			osc[j].sustain = 0.6
		osc[0].factor = 1
		osc[0].amplitude = 0.5
		/*osc[1].factor = 1.9881
		osc[1].amplitude = 0.7
		osc[2].factor = 3.9821 // 1.72
		osc[2].amplitude = 0.3
		osc[3].factor = 1.00621
		osc[3].amplitude = 0.5
		osc[4].factor = 1.9934
		osc[4].amplitude = 0.7*/
		OscillatorLink l
		l.source = 0
		l.dest = -1
		link.add(l)
		/*l.source = 1
		l.dest = 0
		link.add(l)
		l.source = 2
		l.dest = 1
		link.add(l)
		l.source = 3
		l.dest = -1
		link.add(l)
		l.source = 4
		l.dest = 3
		link.add(l)*/
	void __init__()
		reset()
	void __assign__(FMConfig o)

class OscillatorState
	float phi, inp
	float last_before_release

class NoteState
	OscillatorState[NUM_OSCILLATORS] osc

class FMState : PluginData
	NoteState[128] note
	overwrite void reset()
		for int i, 0, 128
			for int j, 0, NUM_OSCILLATORS
				note[i].osc[j].inp = 0
				note[i].osc[j].phi = 0
	void __init__()
		reset()

class FMPanel : ConfigPanel
	FMConfig *fc
	overwrite FMSynthesizer *c
	void __init__(FMSynthesizer *_s)
		super.__init__(_s)
		fc = &c.config
		addGrid("", 0, 0, 8, NUM_OSCILLATORS + 1, "main_table")
		setTarget("main_table", 0)
		addText("Frequency", 0, 0, 0, 0, "")
		addText("Amplitude", 1, 0, 0, 0, "")
		addText("Initial", 2, 0, 0, 0, "")
		addText("Peak", 3, 0, 0, 0, "")
		addText("Sustain", 4, 0, 0, 0, "")
		addText("Attack (ms)", 5, 0, 0, 0, "")
		addText("Decay (ms)", 6, 0, 0, 0, "")
		addText("Release (ms)", 7, 0, 0, 0, "")
		for int j, 0, NUM_OSCILLATORS
			addSpinButton("0\\0\\32\\0.001", 0, j + 1, 0, 0, "factor_" + j)
			addSpinButton("0\\0\\32\\0.001", 1, j + 1, 0, 0, "amplitude_" + j)
			addSpinButton("0\\0\\1\\0.001", 2, j + 1, 0, 0, "initial_" + j)
			addSpinButton("0\\0\\1\\0.001", 3, j + 1, 0, 0, "peak_" + j)
			addSpinButton("0\\0\\1\\0.001", 4, j + 1, 0, 0, "sustain_" + j)
			addSpinButton("0\\0\\1000\\0.1", 5, j + 1, 0, 0, "attack_" + j)
			addSpinButton("0\\0\\1000\\0.1", 6, j + 1, 0, 0, "decay_" + j)
			addSpinButton("0\\0\\1000\\0.1", 7, j + 1, 0, 0, "release_" + j)
		event("*", &onChange)
	
	void onChange()
		for int j, 0, NUM_OSCILLATORS
			fc.osc[j].factor = getFloat("factor_" + j)
			fc.osc[j].amplitude = getFloat("amplitude_" + j)
			fc.osc[j].initial = getFloat("initial_" + j)
			fc.osc[j].peak = getFloat("peak_" + j)
			fc.osc[j].sustain = getFloat("sustain_" + j)
			fc.osc[j].attack = getFloat("attack_" + j) / 1000
			fc.osc[j].decay = getFloat("decay_" + j) / 1000
			fc.osc[j].release = getFloat("release_" + j) / 1000
		notify()
	
	overwrite void update()
		for int j, 0, NUM_OSCILLATORS
			setFloat("factor_" + j, fc.osc[j].factor)
			setFloat("amplitude_" + j, fc.osc[j].amplitude)
			setFloat("initial_" + j, fc.osc[j].initial)
			setFloat("peak_" + j, fc.osc[j].peak)
			setFloat("sustain_" + j, fc.osc[j].sustain)
			setFloat("attack_" + j, fc.osc[j].attack * 1000)
			setFloat("decay_" + j, fc.osc[j].decay * 1000)
			setFloat("release_" + j, fc.osc[j].release * 1000)
		

class FMSynthesizer : Synthesizer
	FMConfig config
	FMState state

	overwrite void reset()
		state.reset()

	overwrite ConfigPanel *createPanel()
		return new FMPanel(self)

	overwrite void renderNote(BufferBox buf, Range r, float pitch, float volume)
		int n = pitch + 0.4
		float freq = pitch_to_freq(pitch)
		float w_base = freq * 2.0 * pi / sample_rate
		NoteState *ns = &state.note[n]
		
		float[NUM_OSCILLATORS] w
		float[NUM_OSCILLATORS] oup
		int[NUM_OSCILLATORS] attack
		int[NUM_OSCILLATORS] decay
		int[NUM_OSCILLATORS] release
		int[NUM_OSCILLATORS] t1
		float[NUM_OSCILLATORS] c_attack
		float[NUM_OSCILLATORS] c_decay
		float[NUM_OSCILLATORS] c_release
		
		keep_notes = 0
		
		for int j, 0, NUM_OSCILLATORS
			w[j] = w_base * config.osc[j].factor
			attack[j] = sample_rate * config.osc[j].attack
			decay[j] = sample_rate * config.osc[j].decay
			release[j] = sample_rate * config.osc[j].release
			t1[j] = attack[j] + decay[j]
			c_attack[j] = log(config.osc[j].peak / config.osc[j].initial) / attack[j]
			c_decay[j] = log(config.osc[j].sustain / config.osc[j].peak) / decay[j]
			c_release[j] = log(0.01 / config.osc[j].sustain) / release[j]
			if release[j] > keep_notes
				keep_notes = release[j]
			

		int i0 = max(r.offset, 0)
		int i1 = min(r.offset + r.length + keep_notes, buf.num)

		for int i, i0, i1
			float final = 0
			int dt = i - r.offset
			
			// oscillate
			for int j, 0, NUM_OSCILLATORS
				ns.osc[j].phi += w[j] * (1 + ns.osc[j].inp)
				oup[j] = sin(ns.osc[j].phi) * config.osc[j].amplitude
				ns.osc[j].inp = 0
				
				// hull curve
				float h
				if dt > r.length
					h = ns.osc[j].last_before_release * exp(c_release[j] * (dt - r.length))
				else
					if dt < attack[j]
						h = config.osc[j].initial * exp(c_attack[j] * dt)
					else if dt < t1[j]
						h = config.osc[j].peak * exp(c_decay[j] * (dt - attack[j]))
					else
						h = config.osc[j].sustain
					ns.osc[j].last_before_release = h
				oup[j] *= h
			
			// transport
			for l in config.link
				if l.dest >= 0
					ns.osc[l.dest].inp += oup[l.source]
				else
					final += oup[l.source]
					
			// output
			float d = final * volume
			buf.r[i] += d
			buf.l[i] += d
