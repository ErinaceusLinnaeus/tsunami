use "../api.kaba"
use "../helper/tone.kaba"

const int NUM_OSCILLATORS = 6



class OscillatorState
	float input, output
	float volume
	float phi
	EnvelopeADSR env
	void __init__()
		volume = 0
		input = 0
		output = 0
		phi = 0
		env.reset()

enum
	TYPE_SINE
	TYPE_SQUARE
	TYPE_SAW

class OscillatorConfig
	float factor
	float amplitude
	float initial, peak, sustain
	float attack, decay, release
	int _type
	bool[NUM_OSCILLATORS] target
	bool target_out
	void __init__()
		reset()
	void reset()
		factor = 1
		amplitude = 0
		initial = 0.01
		peak = 1
		sustain = 0.6
		attack = 0.01
		decay = 0.4
		release = 0.4
		_type = TYPE_SINE
		for t in target
			t = false
		target_out = false

class OscillatorLink
	int source, dest

class FMConfig extends PluginData
	OscillatorConfig[NUM_OSCILLATORS] osc
	//OscillatorLink[] link
	override void reset()
		//link.clear()
		for o in osc
			o.reset()
		osc[0].factor = 1
		osc[0].amplitude = 0.5
		osc[0].target_out = true
	void clear_links()
		for o in osc
			for t in o.target
				t = false
			o.target_out = false

class FMPanel extends ConfigPanel
	FMConfig *fc
	int chosen
	Menu* menu_top
	Menu* menu_osci
	
	float width, height
	complex[NUM_OSCILLATORS] p_osci
	complex p_out
	
	override FMSynthesizer *c
	override void __init__(Module *_s)
		fc = &c.config
		
		from_source("
Grid ? ''
	DrawingArea area '' height=120 expandx noexpandy
	---|
	Grid ? ''
		Label ? 'Freq Multiplier'
		SpinButton factor '' range=0:32:0.001 expandx
		---|
		Label ? 'Amplitude'
		SpinButton amplitude '' range=0:100:0.001
		---|
		Label ? 'Initial'
		SpinButton initial '0' range=0:1:0.001
		---|
		Label ? 'Peak'
		SpinButton peak '0' range=0:1:0.001
		---|
		Label ? 'Sustain'
		SpinButton sustain '0' range=0:1:0.001
		---|
		Label ? 'Attack (ms)'
		SpinButton attack '0' range=0:1000:0.1
		---|
		Label ? 'Decay (ms)'
		SpinButton decay '0' range=0:1000:0.1
		---|
		Label ? 'Release (ms)'
		SpinButton release '0' range=0:1000:0.1")
		
		event_x("area", "hui:draw", &on_draw)
		event_x("area", "hui:left-button-down", &on_left_button_down)
		event_x("area", "hui:right-button-down", &on_right_button_down)
		let ids = ["factor", "amplitude", "initial", "peak", "sustain", "attack", "decay", "release", "type"]
		for id in ids
			event(id, &on_change)
		chosen = 0
		
		menu_top = new Menu
		menu_top.add("Topology", "label-top")
		menu_top.enable("label-top", false)
		menu_top.add("o-o", "top-0")
		menu_top.add("o   o", "top-1")
		menu_top.add("o-o-o", "top-2")
		menu_top.add("o-(o   o)", "top-3")
		menu_top.add("o-o   o", "top-4")
		menu_top.add("o-o-o   o-o-o", "top-98")
		menu_top.add("o-o-o   o-o   o", "top-99")
		for i in 0:100
			event("top-" + i, &on_topology)

		menu_osci = new Menu
		menu_osci.add("Oscillator", "label")
		menu_osci.enable("label", false)
		menu_osci.add("sine", "type-sine")
		menu_osci.add("square", "type-square")
		menu_osci.add("saw", "type-saw")
		event("type-sine", &on_type_sine)
		event("type-square", &on_type_square)
		event("type-saw", &on_type_saw)
	
	void update_osci_pos()
		// initial
		p_out = complex(40, 50)
		for p,i in p_osci
			p = complex((i % 3) * 100 + 100, i * 20 + 10 + pow((i%3),2)*3)
			bool has_links = fc.osc[i].target_out
			for t in fc.osc[i].target
				has_links = has_links or t
			if !has_links
				p += complex(1000,1000)
		for i in 0:200
			iterate_osci_pos()
	complex _f_link(complex a, complex b)
		float d = (b - a).abs()
		complex dir = (b - a) * (1/d)
		return dir * (d - 100) * 0.1 + complex(0, (b.y-a.y) * 0.05)
	complex _f_free(complex a, complex b)
		float d = (b - a).abs()
		complex dir = (b - a) * (1/d)
		return dir * min(d - 50, 0) * 0.2
	void iterate_osci_pos()
		complex[NUM_OSCILLATORS] f
		for o,i in fc.osc
			f[i] = complex(0,0)
			for o2,j in fc.osc
				if i == j
					continue
				if linked(i,j)
					f[i] += _f_link(p_osci[i], p_osci[j])
				else
					f[i] += _f_free(p_osci[i], p_osci[j])
			if o.target_out
				f[i] += _f_link(p_osci[i], p_out)
		for o,i in fc.osc
			p_osci[i] += f[i]
	bool linked(int i, int j)
		return fc.osc[i].target[j] or fc.osc[j].target[i]
	
	complex osci_pos(int index)
		if index < 0
			return p_out
		return p_osci[index]

	void draw_type(Painter *p, complex z, int type, float dx, float amp)
		dx /= pi
		float v0 = 0
		float t0 = -pi
		for t in -pi:pi+0.1:0.1
			float v = sin(t)
			if type == TYPE_SQUARE
				if v > 0
					v = 1
				else
					v = -1
			else if type == TYPE_SAW
				v = -1 + 2*loop(t, 0, pi) / pi
			if t > t0
				p.draw_line(z.x + t0*dx, z.y - v0*amp, z.x + t*dx, z.y - v*amp)
			t0 = t
			v0 = v
	
	void draw_osci(Painter *p, int index)
		let z = osci_pos(index)
		p.set_color(ColorInterpolate(colors.selection, colors.background, 0.7))
		if index == chosen
			p.set_color(colors.selection)
		p.draw_circle(z.x, z.y, 18)
	
		let o = fc.osc[index]
		p.set_color(colors.text)
		draw_type(p, z, o._type, 12, 7)
	
	void draw_link(Painter *p, int a, int b)
		p.set_color(colors.text)
		let z1 = osci_pos(a)
		let z2 = osci_pos(b)
		p.draw_line(z1.x - 20, z1.y, z2.x + 20, z2.y)
		
	void on_draw(Painter *p)
		width = p.width
		height = p.height
		p.set_color(colors.background)
		p.draw_rect(0, 0, width, height)
		
		p.set_color(colors.text)
		p.draw_str(p_out.x-25, p_out.y-8, "out")
		
		for j in 0:NUM_OSCILLATORS
			draw_osci(p, j)
		for o,j in fc.osc
			for k in 0:NUM_OSCILLATORS
				if o.target[k]
					draw_link(p, j, k)
			if o.target_out
				draw_link(p, j, -1)
	
	int hover()
		let e = HuiGetEvent()
		for i in 0:NUM_OSCILLATORS
			let z = osci_pos(i)
			if abs(e.mouse_x - z.x) + abs(e.mouse_y - z.y) < 20
				return i
		return -1
	
	void on_left_button_down()
		int h = hover()
		if h >= 0
			set_chosen(h)
		
	void on_right_button_down()
		int h = hover()
		if h >= 0
			set_chosen(h)
			menu_osci.popup(self)
		else
			menu_top.popup(self)
	
	void set_chosen(int i)
		chosen = i
		redraw("area")
		update()
	
	void on_topology()
		int x = HuiGetEvent().id[4:].int()
		fc.clear_links()
		fc.osc[0].target_out = true
		if x == 0
			fc.osc[1].target[0] = true
		else if x == 1
			fc.osc[1].target_out = true
		else if x == 2
			fc.osc[1].target[0] = true
			fc.osc[2].target[1] = true
		else if x == 3
			fc.osc[1].target[0] = true
			fc.osc[2].target[0] = true
		else if x == 4
			fc.osc[1].target[0] = true
			fc.osc[2].target_out = true
		else if x == 98
			fc.osc[1].target[0] = true
			fc.osc[2].target[1] = true
			fc.osc[3].target_out = true
			fc.osc[4].target[3] = true
			fc.osc[5].target[4] = true
		else if x == 99
			fc.osc[1].target[0] = true
			fc.osc[2].target[1] = true
			fc.osc[3].target_out = true
			fc.osc[4].target[3] = true
			fc.osc[5].target_out = true
		update_osci_pos()
		redraw("area")
		changed()
	
	void on_type_sine()
		fc.osc[chosen]._type = TYPE_SINE
		redraw("area")
		changed()
	
	void on_type_square()
		fc.osc[chosen]._type = TYPE_SQUARE
		redraw("area")
		changed()
		
	void on_type_saw()
		fc.osc[chosen]._type = TYPE_SAW
		redraw("area")
		changed()

	void on_change()
		if chosen < 0
			return
		let o = &fc.osc[chosen]
		o.factor = get_float("factor")
		o.amplitude = get_float("amplitude")
		o.initial = get_float("initial")
		o.peak = get_float("peak")
		o.sustain = get_float("sustain")
		o.attack = get_float("attack") / 1000
		o.decay = get_float("decay") / 1000
		o.release = get_float("release") / 1000
		changed()
	
	override void update()
		if chosen >= 0
			let o = &fc.osc[chosen]
			set_float("factor", o.factor)
			set_float("amplitude", o.amplitude)
			set_float("initial", o.initial)
			set_float("peak", o.peak)
			set_float("sustain", o.sustain)
			set_float("attack", o.attack * 1000)
			set_float("decay", o.decay * 1000)
			set_float("release", o.release * 1000)
		update_osci_pos()
		redraw("area")



class FMRenderer extends PitchRenderer
	OscillatorState[NUM_OSCILLATORS] osc
	OscillatorConfig[NUM_OSCILLATORS] conf
	int num_osc_active
	override FMSynthesizer *synth
	
	override void __init__(Synthesizer *s, int _pitch)
		//super.__init__(s, _pitch)
		num_osc_active = 0

	override void on_end()
		for o,oi in osc
			o.env.end()
	override void on_start(float _volume)
		num_osc_active = NUM_OSCILLATORS
		for o,oi in osc
			// TODO: volume should only effect "output" oscs
			o.env.start(_volume * conf[oi].amplitude)

	override void on_config()
		for o,i in osc
			conf[i] = synth.config.osc[i]
			OscillatorConfig* c = &conf[i]
			o.env.set(c.attack, c.decay, c.sustain, c.release, synth.sample_rate)
			o.env.set2(c.initial, c.peak)

	override bool render(AudioBuffer buf)
		for i in 0:len(buf)

			for o,oi in osc
				o.volume = o.env.get()
				if o.env.just_killed
					num_osc_active --
					if num_osc_active == 0
						return false
					
				OscillatorConfig *co = &conf[oi]
				o.phi += delta_phi * (1 + o.input) * co.factor
				if co._type == TYPE_SINE
					o.output = sin(o.phi) * o.volume
				else if co._type == TYPE_SQUARE
					if sin(o.phi) > 0
						o.output = o.volume
					else
						o.output = -o.volume
				else if co._type == TYPE_SAW
					o.output = (loop(o.phi, 0, 2*pi) / pi - 1) * o.volume
				o.input = 0
				if o.phi > 8*pi
					o.phi = loop(o.phi, 0, 8*pi)
			
			// transport
			for o,oi in osc
				OscillatorConfig *co = &conf[oi]
				if co.target_out
					buf.l[i] += o.output
				for t,j in co.target
					if t
						osc[j].input += o.output
		buf.auto_generate_channels()
		return true

class FMSynthesizer extends Synthesizer
	FMConfig config

	override ConfigPanel *create_panel()
		return new FMPanel(self)

	override PitchRenderer* create_pitch_renderer(int pitch)
		return new FMRenderer(self, pitch)

			
	
