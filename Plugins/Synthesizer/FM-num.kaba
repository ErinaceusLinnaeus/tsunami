use "../api.kaba"
use "../tone.kaba"

const int NUM_OSCILLATORS = 6

class OscillatorConfig
	float factor
	float amplitude
	float initial, peak, sustain
	float attack, decay, release

class OscillatorLink
	int source, dest

class FMConfig
	OscillatorConfig osc[NUM_OSCILLATORS]
	OscillatorLink link[]
	void __init__()
		osc[0].factor = 1
		osc[0].amplitude = 1
		osc[1].factor = 1.99
		osc[1].amplitude = 0.7
		osc[2].factor = 3.99 // 1.72
		osc[2].amplitude = 0.3
		for int j, 0, NUM_OSCILLATORS
			osc[j].attack = 0.01
			osc[j].decay = 0.4
			osc[j].release = 0.4
			osc[j].initial = 0.01
			osc[j].peak = 1
			osc[j].sustain = 0.6
		OscillatorLink l
		l.source = 0
		l.dest = -1
		link.add(l)
		l.source = 1
		l.dest = 0
		link.add(l)
		l.source = 2
		l.dest = 1
		link.add(l)
	void __assign__(FMConfig o)

class OscillatorState
	float phi, inp
	float last_before_release

class NoteState
	OscillatorState osc[NUM_OSCILLATORS]

class FMState
	NoteState note[128]
	void __init__()
		for int i, 0, 128
			for int j, 0, NUM_OSCILLATORS
				note[i].osc[j].inp = 0
				note[i].osc[j].phi = 0
	void __assign__(FMState o)
	

class FMSynthesizer : Synthesizer
	FMConfig config
	FMState state
	overwrite void RenderNote(BufferBox buf, Range r, float pitch, float volume)
		int n = pitch + 0.4
		float freq = pitch_to_freq(pitch)
		float w_base = freq * 2.0 * pi / sample_rate
		NoteState *ns = &state.note[n]
		
		float w[NUM_OSCILLATORS]
		float oup[NUM_OSCILLATORS]
		int attack[NUM_OSCILLATORS]
		int decay[NUM_OSCILLATORS]
		int release[NUM_OSCILLATORS]
		int t1[NUM_OSCILLATORS]
		float c_attack[NUM_OSCILLATORS]
		float c_decay[NUM_OSCILLATORS]
		float c_release[NUM_OSCILLATORS]
		
		keep_notes = 0
		
		for int j, 0, NUM_OSCILLATORS
			w[j] = w_base * config.osc[j].factor
			attack[j] = sample_rate * config.osc[j].attack
			decay[j] = sample_rate * config.osc[j].decay
			release[j] = sample_rate * config.osc[j].release
			t1[j] = attack[j] + decay[j]
			c_attack[j] = log(config.osc[j].peak / config.osc[j].initial) / attack[j]
			c_decay[j] = log(config.osc[j].sustain / config.osc[j].peak) / decay[j]
			c_release[j] = log(0.01 / config.osc[j].sustain) / release[j]
			if release[j] > keep_notes
				keep_notes = release[j]
			

		int i0 = max(r.offset, 0)
		int i1 = min(r.offset + r.length + keep_notes, buf.num)

		for int i, i0, i1
			float final = 0
			int dt = i - r.offset
			
			// oscillate
			for int j, 0, NUM_OSCILLATORS
				ns.osc[j].phi += w[j] * (1 + ns.osc[j].inp)
				oup[j] = sin(ns.osc[j].phi) * config.osc[j].amplitude
				ns.osc[j].inp = 0
				
				// hull curve
				float h
				if dt > r.length
					h = ns.osc[j].last_before_release * exp(c_release[j] * (dt - r.length))
				else
					if dt < attack[j]
						h = config.osc[j].initial * exp(c_attack[j] * dt)
					else if dt < t1[j]
						h = config.osc[j].peak * exp(c_decay[j] * (dt - attack[j]))
					else
						h = config.osc[j].sustain
					ns.osc[j].last_before_release = h
				oup[j] *= h
			
			// transport
			for l in config.link
				if l.dest >= 0
					ns.osc[l.dest].inp += oup[l.source]
				else
					final += oup[l.source]
					
			// output
			float d = final * volume
			buf.r[i] += d
			buf.l[i] += d
