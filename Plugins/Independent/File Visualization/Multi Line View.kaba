use tsunami
use hui

func smooth(t: float) -> float
	if t < 0.5
		return 2*t^2
	return 1 - 2*(1-t)^2

class MyDialog extends hui.Dialog
	mlp: MultiLinePainter*
	config_visible = false
	session: Session*
	
	mlv: MultiLineView*
	config: MultiLineView.Config*
	use config
	
	y_offset_start = 0.0
	y_offset_target = 0.0
	y_offset_t = -1.0
	
	line_samples: int[]
	line_y0: float[]
	area: rect

	func __init__(parent: hui.Window, _mlv: MultiLineView)
		super.__init__("Multi Line View", 800, 600, parent, true)
		
		mlv = &_mlv
		config = &mlv.config
		session = mlv.session
		
		from_source("Dialog multi-line-view 'Multi Line View' resizable headerbar
	Grid ? '' vertical
		Grid ? ''
			DrawingArea area '' expandx grabfocus
			Grid config-grid '' noexpandx width=300 hidden
				Grid ? ''
					Label l-line-height 'Line height'
					SpinButton line-height '{{line_height}}' expandx
					---|
					Label l-line-space 'Line space'
					SpinButton line-space '{{line_space}}' range=0:2:0.01
					---|
					Label l-track-space 'Tack space'
					SpinButton track-space '{{track_space}}' range=0:2:0.01
					---|
					Label l-x-scale 'Horizontal scale'
					SpinButton x-scale '{{x_scale}}' range=0.01:10:0.01
					---|
					CheckBox allow-shadows 'Shadows'
				---|
				ListView tracks 'Track\\Classical\\TAB' format=tCC")
		set_target(":header:")
		add_button("", 0, 0, "play")
		set_image("play", "hui:media-play")
		add_button("", 0, 1, "config")
		set_image("config", "hui:properties")
		
		for t,i in weak(session.song.tracks)
			if t.type == SignalType.MIDI
				track_mode.add(true)
				track_mode.add(true)
				add_string("tracks", "{{t.nice_name()}}\\true\\true")
			else
				track_mode.add(false)
				track_mode.add(false)
				add_string("tracks", "{{t.nice_name()}}\\false\\false")
		
		#var me = &self
		event("config", on_config)#lambda(me: MyDialog) me.hide_control("config-grid", false))
		event("line-height", on_update)
		event("line-space", on_update)
		event("track-space", on_update)
		event("x-scale", on_update)
		event("shadows", on_update)
		event("play", on_play)
		event_x("tracks", "hui:change", on_update)
		event_x("area", "hui:left-button-down", on_click)
		event_x("area", "hui:mouse-wheel", on_scroll)
		event_x("area", "hui:key-down", on_key)
		event("hui:close", on_close)
		
		#session.view.signal_chain.subscribe(self, on_preview_change, "Change")
		session.view.signal_chain.subscribe(self, on_preview_tick, "Tick")
		
		mlp = new MultiLinePainter(session.song, colors)
	
	func override __delete__()
		session.view.signal_chain.unsubscribe(self)
		del mlp
	
	func mut on_preview_change()
	func mut on_preview_tick()
		if session.view.is_playback_active()
			make_sure_sample_on_screen(session.view.playback_pos())
			force_redraw()
	
	func mut make_sure_sample_on_screen(s: int)
		if y_offset_t >= 0
			return
		var y0 = sample_to_screen(s).y
		var dy = mlp.get_line_dy()
		if y0 < 0
			set_scroll_target(y_offset + y0)
		else if y0 + dy*2 > area.y2
			set_scroll_target(y_offset + (y0 + min(dy*2 - area.y2, 0.0)))
		
	func mut set_scroll_target(y: float)
		#y_offset = y
		y_offset_start = y_offset
		y_offset_target = y
		y_offset_t = 0
		mlv.changed()
	
	func mut on_close()
		mlv.stop()
	
	func mut on_play()
		if session.view.is_playback_active()
			if session.view.is_paused()
				session.view.signal_chain.start()
			else
				session.view.signal_chain.stop()
		else
			session.view.play()
	
	func mut on_key()
		var e = hui.get_event()
		if e.key == hui.KEY_SPACE
			on_play()
	
	func mut on_config()
		config_visible = not config_visible
		if config_visible
			set_options("config-grid", "visible")
		else
			set_options("config-grid", "hidden")
	
	func mut on_update()
		line_height = get_float("line-height")
		line_space = get_float("line-space")
		track_space = get_float("track-space")
		x_scale = get_float("x-scale")
		allow_shadows = is_checked("allow-shadows")
		for t,i in weak(session.song.tracks)
			track_mode[i * 2    ] = (get_cell("tracks", i, 1) == "true")
			track_mode[i * 2 + 1] = (get_cell("tracks", i, 2) == "true")
		mlv.changed()
	
	func mut on_config_changed()
		force_redraw()
	
	func mut on_scroll()
		var e = hui.get_event()
		var speed = session.view.mouse_wheel_speed #float(hui.config["View.MouseWheelSpeed"])
		config.y_offset = clamp(y_offset + e.scroll.y*20*speed, 0.0, 100000)
		mlv.changed()
	
	func mut on_click()
		var e = hui.get_event()
		session.view.set_playback_pos(screen_to_sample(e.mouse))
	
	func screen_to_sample(pos: vec2) -> int
		for y0,i in line_y0[:-1]
			if pos.y >= y0 and pos.y < line_y0[i+1]
				return line_samples[i] + (line_samples[i+1] - line_samples[i]) * (pos.x - border) / (area.width() - 2*border)
		return -1
	
	func sample_to_screen(s: int) -> vec2
		for s0,i in line_samples[:-1]
			if s >= s0 and s < line_samples[i+1]
				return [0,line_y0[i]] # X: TODO
		return [0,0]
		

	func override on_draw(p: Painter)
		area = [0,p.width, 0,p.height]
		var conf = dyn([])
		for t,i in weak(session.song.tracks)
			if t.type != SignalType.MIDI
				continue
			if track_mode[i*2] and track_mode[i*2+1]
				conf.add(dyn({"index":i, "classical":true, "tab":true}))
			else if track_mode[i*2]
				conf.add(dyn({"index":i, "classical":true}))
			else if track_mode[i*2+1]
				conf.add(dyn({"index":i, "tab":true}))
		mlp.set_context(conf, p.width, 44100*p.width/180 / x_scale)
		mlp.set(dyn({"border": border,
			"line-height": line_height,
			"line-space": line_height * line_space,
			"track-space": line_height * track_space,
			"allow-shadows": allow_shadows,
			"antialiasing": true,
			"collapse-midi": true}))
		var y0 = 10.0 - y_offset
		var offset = 0
		var dy = mlp.get_line_dy()
		line_samples.clear()
		line_y0.clear()
		while offset < session.song.range().end()
			line_samples.add(offset)
			line_y0.add(y0)
			var s0 = offset
			var y00 = y0
			
			var line_samples = mlp.next_line_samples(offset)
			if y0+dy > 0 and y0 < p.height
				# on screen
				y0 = mlp.draw_next_line(p, offset, [0, y0])
			else
				offset += line_samples
				y0 += dy
			
			#line_samples.add(offset - s0)
			
			if session.view.is_playback_active()
				var pos = session.view.playback_pos()
				if pos >= s0 and pos < offset
					var w = p.width - border*2
					var x = border + float(pos - s0) * w / float(offset - s0)
					p.set_color([0.2, 0.8, 0.2, 1]) #colors.
					p.set_line_width(3)
					p.draw_line([x, y00], [x, y0])
		line_samples.add(offset)
		line_y0.add(y0)
		
		if y_offset_t >= 0
			y_offset = y_offset_start + smooth(y_offset_t) * (y_offset_target - y_offset_start)
			y_offset_t += 0.1
			if y_offset_t >= 1
				y_offset_t = -1
			hui.run_later(0.02, force_redraw)
	func force_redraw()
		redraw("area")

class MultiLineView extends TsunamiPlugin
	dlg: MyDialog*
	
	class Config extends Module.Config
		line_height = 50.0
		line_space = 0.8
		track_space = 0.4
		border = 20.0
		x_scale = 1.0
		track_mode: bool[]
		y_offset = 0.0
		allow_shadows = false
		func override reset()
			line_height = 50.0
			line_space = 0.8
			track_space = 0.4
			border = 20.0
			x_scale = 1.0
			track_mode.clear()
			y_offset = 0.0
			allow_shadows = false
	var config: Config

	func override on_start()
		dlg = new MyDialog(session.win, self)
		dlg.show()
		
	func override on_stop()
		del dlg
	
	func override on_config()
		if dlg
			dlg.on_config_changed()
