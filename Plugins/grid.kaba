


float log2lin(float f, float f_min, float f_max)
	return exp(f * log(f_max / f_min)) * f_min

float lin2log(float f, float f_min, float f_max)
	return log(f / f_min) / log(f_max / f_min)

class GridPartition
	float min, max
	float step
	float factor
	int decimals

GridPartition get_lin_partition(float f_min, float f_max, float w)
	float d = (f_max - f_min) / w * 100
	GridPartition r
	r.step = 1
	float e = log(d) / log(10)
	float e_floor = i2f(f2i(e))
	if e < 0
		e_floor -= 1
	r.step = pow(10, e_floor)
	r.factor = d / r.step
	r.decimals = f2i(max(-e_floor, 0))
	r.min = i2f(f2i(f_min / r.step) * r.step)
	r.max = f_max
	return r

class GridData
	float x0, y0, x, y, w, h
	float x_val_min, x_val_max
	bool x_log
	string x_unit
	float y_val_min, y_val_max
	bool y_log
	string y_unit
	
	color col_bg
	color col_grid
	color col_grid2
	color col_text

	void SetXAxis(float val_min, float val_max, bool _log, string unit)
		x_val_min = val_min
		x_val_max = val_max
		x_log = _log
		x_unit = unit

	void SetYAxis(float val_min, float val_max, bool _log, string unit)
		y_val_min = val_min
		y_val_max = val_max
		y_log = y_log
		y_unit = unit
	
	float rel2valx(float __x)
		if x_log
			return log2lin(__x, x_val_min, x_val_max)
		return __x * (x_val_max - x_val_min) + x_val_min
		
	float projectx(float __x)
		if x_log
			return lin2log(__x, x_val_min, x_val_max) * w + x
		else
			return ((__x - x_val_min) / (x_val_max - x_val_min)) * w + x
		
	float projecty(float __y)
		if y_log
			return lin2log(__y, y_val_min, y_val_max) * h + y
		else
			return h * (y_val_max - __y) / (y_val_max - y_val_min) + y

	complex project2(complex z)
		return complex(projectx(z.x), projecty(z.y))

	vector project3(vector z)
		return vector(projectx(z.x), projecty(z.y), z.z)
	
	float unprojectx(float __x)
		if x_log
			return log2lin((__x - x) / w, x_val_min, x_val_max)
		else
			return (__x - x) / w * (x_val_max - x_val_min) + x_val_min
	
	float unprojecty(float __y)
		if y_log
			return log2lin((__y - y) / h, y_val_min, y_val_max)
		else
			return y_val_max - (__y - y) / h * (y_val_max - y_val_min)

	complex unproject2(complex z)
		return complex(unprojectx(z.x), unprojecty(z.y))

	vector unproject3(vector z)
		return vector(unprojectx(z.x), unprojecty(z.y), z.z)
	
	
	void DrawLinY(painter c, GridPartition part)
		c.SetLineWidth(0.9)
		c.SetFontSize(7)
		float yy = part.min
		while yy <= part.max and part.step > 0
			c.SetColor(col_grid)
			float vy = projecty(yy)
			c.DrawLine(x, vy, x + w, vy)
			c.SetColor(col_text)
			string t = yy.str2(part.decimals)
			t += " "
			t += y_unit
			c.DrawStr(x0 + 2, vy - 6, t)
			if part.factor < 3
				c.SetColor(col_grid2)
				vy = projecty(yy + part.step / 2)
				c.DrawLine(x, vy, x + w, vy)
			yy += part.step
	
	void DrawLinX(painter c, GridPartition part)
		c.SetLineWidth(0.9)
		c.SetFontSize(7)
		float xx = part.min
		while xx <= part.max and part.step > 0
			c.SetColor(col_grid)
			float vx = projectx(xx)
			c.DrawLine(vx, y, vx, y + h)
			c.SetColor(col_text)
			string t = xx.str2(part.decimals)
			t += " "
			t += x_unit
			c.DrawStr(vx, y + h + 5, t)
			if part.factor < 3
				c.SetColor(col_grid2)
				vx = projectx(xx + part.step / 2)
				c.DrawLine(vx, y, vx, y + h)
			xx += part.step

	void Draw(painter c, float _x0, float _y0, float _w, float _h)
	
		_y0 += 3
		x0 = _x0
		y0 = _y0
		x = _x0 + 40
		y = _y0
		_w -= 43
		_h -= 23
		w = _w
		h = _h
		
		
		col_grid = color(1, 0.8, 0.8, 0.8)
		col_grid2 = color(1, 0.9, 0.9, 0.9)
		col_text = color(1, 0.4, 0.4, 0.4)
		col_bg = White
		
		// background
		c.SetColor(col_bg)
		c.DrawRect(x, y, w, h)
	
		c.SetLineWidth(0.9)
		c.SetFontSize(7)
		if x_log
			float ff = x_val_min
			while ff <= x_val_max
				float fx = projectx(ff)
				c.SetColor(col_grid)
				c.DrawLine(fx, y, fx, y + h)
				c.SetColor(col_text)
				c.DrawStr(fx, y + h + 5, ff.str2(0) + " " + x_unit)
				fx = projectx(ff * sqrt(2))
				c.SetColor(col_grid2)
				c.DrawLine(fx, y, fx, y + h)
				ff *= 2
		else
			GridPartition part = get_lin_partition(x_val_min, x_val_max, w)
			DrawLinX(c, part)
		part = get_lin_partition(y_val_min, y_val_max, h)
		DrawLinY(c, part)
	
	void DrawCurve(painter c, FloatInterpolator fi, bool fill_below)
		float tt[], xx[], yy[]
		tt = rangef(0, 1, 0.003)
		yy = fi.get_list(tt)
		for int i, 0, tt.num
			complex zz = project2(complex(rel2valx(tt[i]), yy[i]))
			yy[i] = zz.y
			xx.add(zz.x)
		if fill_below
			xx.add(x + w)
			yy.add(y + h)
			xx.add(x)
			yy.add(y + h)
			c.SetColor(color(0.3, 0.3, 0.3, 1))
			c.DrawPolygon(xx, yy)
			xx.resize(xx.num - 2)
			yy.resize(yy.num - 2)
		c.SetLineWidth(2)
		c.SetColor(Black)
		c.DrawLines(xx, yy)
	
	void DrawCurveB(painter c, float _x[], float _y[], bool fill_below, color col)
		float xx[], yy[]
		for int i, 0, _x.num
			complex zz = project2(complex(_x[i], _y[i]))
			yy.add(zz.y)
			xx.add(zz.x)
		if fill_below
			xx.add(x + w)
			yy.add(y + h)
			xx.add(x)
			yy.add(y + h)
			color col2 = col
			col2.a = 0.3
			c.SetColor(col2)
			c.DrawPolygon(xx, yy)
			xx.resize(xx.num - 2)
			yy.resize(yy.num - 2)
		c.SetLineWidth(0.9)
		c.SetColor(col)
		c.DrawLines(xx, yy)
	
	void DrawPoint2(painter c, complex p, bool selected, bool hover)
		complex pp = project2(p)
		c.SetColor(Black)
		float radius = 3
		if hover
			c.SetColor(Red)
			radius = 4
		else if selected
			c.SetColor(color(1, 0.7, 0, 0))
		c.DrawCircle(pp.x, pp.y, radius)
	
	void DrawPoint3(painter c, vector p, bool selected, bool hover)
		vector pp = project3(p)
		c.SetColor(Black)
		float radius = 3
		if hover
			c.SetColor(Red)
			c.DrawStr(pp.x, pp.y - 20, pp.z.str2(1))
			radius = 4
		else if selected
			c.SetColor(color(1, 0.7, 0, 0))
		c.DrawCircle(pp.x, pp.y, radius)
	
	complex GetMouse2()
		float mx = HuiGetEvent().mouse_x
		float my = HuiGetEvent().mouse_y
		return unproject2(complex(mx, my))
	
	vector GetMouse3(float z)
		float mx = HuiGetEvent().mouse_x
		float my = HuiGetEvent().mouse_y
		return unproject3(vector(mx, my, z))
		
	bool MouseOverPoint2(complex q)
		float mx = HuiGetEvent().mouse_x
		float my = HuiGetEvent().mouse_y
		complex p = project2(q)
		return (mx > p.x - 5) and (mx < p.x + 5) and (my > p.y - 5) and (my < p.y + 5)
		
	bool MouseOverPoint3(vector q)
		return MouseOverPoint2(complex(q.x, q.y))
