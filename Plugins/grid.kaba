


float log2lin(float f, float f_min, float f_max)
	return exp(f * log(f_max / f_min)) * f_min

float lin2log(float f, float f_min, float f_max)
	return log(f / f_min) / log(f_max / f_min)

class GridPartition
	float min, max
	float step
	float factor
	int decimals

class AxisData
	float offset, size
	float val_min, val_max
	bool as_log
	string unit
	
	void set(float _val_min, float _val_max, bool _log, string _unit)
		val_min = _val_min
		val_max = _val_max
		as_log = _log
		unit = _unit
	
	float rel2val(float __v)
		if as_log
			return log2lin(__v, val_min, val_max)
		return __v * (val_max - val_min) + val_min
		
	float project(float __v)
		if as_log
			return lin2log(__v, val_min, val_max) * size + offset
		else
			return ((__v - val_min) / (val_max - val_min)) * size + offset

	float unproject(float __v)
		if as_log
			return log2lin((__v - offset) / size, val_min, val_max)
		else
			return (__v - offset) / size * (val_max - val_min) + val_min

	GridPartition get_lin_partition()
		float d = (val_max - val_min) / size * 100
		GridPartition r
		r.step = 1
		float e = log(abs(abs(d))) / log(10)
		float e_floor = i2f(f2i(e))
		if e < 0
			e_floor -= 1
		r.step = pow(10, e_floor)
		r.factor = d / r.step
		r.decimals = f2i(max(-e_floor, 0))
		r.min = i2f(f2i(val_min / r.step) * r.step)
		r.max = val_max
		return r

class GridData
	bool allow_bg
	float x0, y0
	rect plot_rect
	float x, y, w, h
	
	AxisData x_axis, y_axis
	
	color col_bg
	color col_grid
	color col_grid2
	color col_text
	
	void __init__()
		col_grid = color(1, 0.8, 0.8, 0.8)
		col_grid2 = color(1, 0.9, 0.9, 0.9)
		col_text = color(1, 0.4, 0.4, 0.4)
		col_bg = White
		allow_bg = true
		x_axis.set(0, 1, false, "")
		y_axis.set(0, 1, false, "")

	complex project2(complex z)
		return complex(x_axis.project(z.x), y_axis.project(z.y))

	vector project3(vector z)
		return vector(x_axis.project(z.x), y_axis.project(z.y), z.z)

	complex unproject2(complex z)
		return complex(x_axis.unproject(z.x), y_axis.unproject(z.y))

	vector unproject3(vector z)
		return vector(x_axis.unproject(z.x), y_axis.unproject(z.y), z.z)
	
	
	void DrawLinY(Painter *c, GridPartition part)
		c.SetLineWidth(0.9)
		c.SetFontSize(7)
		float yy = part.min
		while yy <= part.max and part.step > 0
			c.SetColor(col_grid)
			float vy = y_axis.project(yy)
			c.DrawLine(x, vy, x + w, vy)
			c.SetColor(col_text)
			string t = yy.str2(part.decimals)
			t += " "
			t += y_axis.unit
			c.DrawStr(x0 + 2, vy - 6, t)
			if part.factor < 3
				c.SetColor(col_grid2)
				vy = y_axis.project(yy + part.step / 2)
				c.DrawLine(x, vy, x + w, vy)
			yy += part.step
	
	void DrawLinX(Painter *c, GridPartition part)
		c.SetLineWidth(0.9)
		c.SetFontSize(7)
		float xx = part.min
		while xx <= part.max and part.step > 0
			c.SetColor(col_grid)
			float vx = x_axis.project(xx)
			c.DrawLine(vx, y, vx, y + h)
			c.SetColor(col_text)
			string t = xx.str2(part.decimals)
			t += " "
			t += x_axis.unit
			c.DrawStr(vx, y + h + 5, t)
			if part.factor < 3
				c.SetColor(col_grid2)
				vx = x_axis.project(xx + part.step / 2)
				c.DrawLine(vx, y, vx, y + h)
			xx += part.step
	
	rect GetPlotRegion(float _x0, float _y0, float _w, float _h)
		return rect(_x0 + 40, _x0 + _w - 3, _y0 + 3, _y0 + _h -20)

	void Draw(Painter *c, float _x0, float _y0, float _w, float _h)
	
		x0 = _x0
		y0 = _y0 + 3
	
		plot_rect = GetPlotRegion(_x0, _y0, _w, _h)
		_y0 += 3
		x = plot_rect.x1
		y = plot_rect.y1
		w = plot_rect.width()
		h = plot_rect.height()
		
		x_axis.offset = x
		x_axis.size = w
		y_axis.offset = y + h
		y_axis.size = -h
		
		// background
		if allow_bg
			c.SetColor(col_bg)
			c.DrawRect(x, y, w, h)
	
		c.SetLineWidth(0.9)
		c.SetFontSize(7)
		if x_axis.as_log
			float ff = x_axis.val_min
			while ff <= x_axis.val_max
				float fx = x_axis.project(ff)
				c.SetColor(col_grid)
				c.DrawLine(fx, y, fx, y + h)
				c.SetColor(col_text)
				c.DrawStr(fx, y + h + 5, ff.str2(0) + " " + x_axis.unit)
				fx = x_axis.project(ff * sqrt(2))
				c.SetColor(col_grid2)
				c.DrawLine(fx, y, fx, y + h)
				ff *= 2
		else
			GridPartition part = x_axis.get_lin_partition()
			DrawLinX(c, part)
		part = y_axis.get_lin_partition()
		DrawLinY(c, part)
	
	void DrawCurve(Painter *c, FloatInterpolator fi, bool fill_below)
		float tt[], yy[]
		complex pp[]
		tt = rangef(0, 1, 0.003)
		yy = fi.getList(tt)
		for int i, 0, tt.num
			complex zz = project2(complex(x_axis.rel2val(tt[i]), yy[i]))
			pp.add(zz)
		if fill_below
			pp.add(complex(x + w, y + h))
			pp.add(complex(x, y + h))
			c.SetColor(color(0.3, 0.3, 0.3, 1))
			c.DrawPolygon(pp)
			pp.resize(pp.num - 2)
		c.SetLineWidth(2)
		c.SetColor(Black)
		c.DrawLines(pp)
	
	void DrawCurveB(Painter *c, complex _p[], bool fill_below, color col)
		complex pp[]
		for int i, 0, _p.num
			pp.add(project2(_p[i]))
		if fill_below
			pp.add(complex(x + w, y + h))
			pp.add(complex(x, y + h))
			color col2 = col
			col2.a = 0.3
			c.SetColor(col2)
			c.DrawPolygon(pp)
			pp.resize(pp.num - 2)
		c.SetLineWidth(0.9)
		c.SetColor(col)
		c.DrawLines(pp)
	
	void DrawPoint2(Painter *c, complex p, bool selected, bool hover)
		complex pp = project2(p)
		c.SetColor(Black)
		float radius = 3
		if hover
			c.SetColor(Red)
			radius = 4
		else if selected
			c.SetColor(color(1, 0.7, 0, 0))
		c.DrawCircle(pp.x, pp.y, radius)
	
	void DrawPoint3(Painter *c, vector p, bool selected, bool hover)
		vector pp = project3(p)
		c.SetColor(Black)
		float radius = 3
		if hover
			c.SetColor(Red)
			c.DrawStr(pp.x, pp.y - 20, pp.z.str2(1))
			radius = 4
		else if selected
			c.SetColor(color(1, 0.7, 0, 0))
		c.DrawCircle(pp.x, pp.y, radius)
	
	complex GetMouse2()
		float mx = HuiGetEvent().mouse_x
		float my = HuiGetEvent().mouse_y
		return unproject2(complex(mx, my))
	
	vector GetMouse3(float z)
		float mx = HuiGetEvent().mouse_x
		float my = HuiGetEvent().mouse_y
		return unproject3(vector(mx, my, z))
		
	bool MouseOverPoint2(complex q)
		float mx = HuiGetEvent().mouse_x
		float my = HuiGetEvent().mouse_y
		complex p = project2(q)
		return (mx > p.x - 5) and (mx < p.x + 5) and (my > p.y - 5) and (my < p.y + 5)
		
	bool MouseOverPoint3(vector q)
		return MouseOverPoint2(complex(q.x, q.y))
