


float log2lin(float f, float f_min, float f_max)
	return exp(f * log(f_max / f_min)) * f_min

float lin2log(float f, float f_min, float f_max)
	return log(f / f_min) / log(f_max / f_min)

class GridPartition
	float min, max
	float step
	float factor
	int decimals

GridPartition get_lin_partition(float f_min, float f_max, float w)
	float d = (f_max - f_min) / w * 100
	GridPartition r
	r.step = 1
	float e = log(d) / log(10)
	float e_floor = i2f(f2i(e))
	if e < 0
		e_floor -= 1
	r.step = pow(10, e_floor)
	r.factor = d / r.step
	r.decimals = f2i(max(-e_floor, 0))
	r.min = i2f(f2i(f_min / r.step) * r.step)
	r.max = f_max
	return r

class GridData
	float x0, y0, x, y, w, h
	float x_val_min, x_val_max
	bool x_log
	string x_unit
	float y_val_min, y_val_max
	bool y_log
	string y_unit
	
	color col_bg
	color col_grid
	color col_grid2
	color col_text

	void SetXAxis(float val_min, float val_max, bool x_log, string unit)
		self.x_val_min = val_min
		self.x_val_max = val_max
		self.x_log = x_log
		self.x_unit = unit

	void SetYAxis(float y_val_min, float y_val_max, bool y_log, string unit)
		self.y_val_min = y_val_min
		self.y_val_max = y_val_max
		self.y_log = y_log
		self.y_unit = unit
	
	float rel2valx(float x)
		if self.x_log
			return log2lin(x, self.x_val_min, self.x_val_max)
		return x * (self.x_val_max - self.x_val_min) + self.x_val_min
		
	float projectx(float x)
		if self.x_log
			return lin2log(x, self.x_val_min, self.x_val_max) * self.w + self.x
		else
			return ((x - self.x_val_min) / (self.x_val_max - self.x_val_min)) * self.w + self.x
		
	float projecty(float y)
		if self.y_log
			return lin2log(y, self.y_val_min, self.y_val_max) * self.h + self.y
		else
			return self.h * (self.y_val_max - y) / (self.y_val_max - self.y_val_min) + self.y

	complex project2(complex z)
		return complex(self.projectx(z.x), self.projecty(z.y))

	vector project3(vector z)
		return vector(self.projectx(z.x), self.projecty(z.y), z.z)
	
	float unprojectx(float x)
		if self.x_log
			return log2lin((x - self.x) / self.w, self.x_val_min, self.x_val_max)
		else
			return (x - self.x) / self.w * (self.x_val_max - self.x_val_min) + self.x_val_min
	
	float unprojecty(float y)
		if self.y_log
			return log2lin((y - self.y) / self.h, self.y_val_min, self.y_val_max)
		else
			return self.y_val_max - (y - self.y) / self.h * (self.y_val_max - self.y_val_min)

	complex unproject2(complex z)
		return complex(self.unprojectx(z.x), self.unprojecty(z.y))

	vector unproject3(vector z)
		return vector(self.unprojectx(z.x), self.unprojecty(z.y), z.z)
	
	
	void DrawLinY(context c, GridPartition part)
		c.SetLineWidth(0.9)
		c.SetFontSize(7)
		float y = part.min
		while y <= part.max and part.step > 0
			c.SetColor(self.col_grid)
			float vy = self.projecty(y)
			c.DrawLine(self.x, vy, self.x + self.w, vy)
			c.SetColor(self.col_text)
			string t = y.str2(part.decimals)
			t += " "
			t += self.y_unit
			c.DrawStr(self.x0 + 2, vy - 6, t)
			if part.factor < 3
				c.SetColor(self.col_grid2)
				vy = self.projecty(y + part.step / 2)
				c.DrawLine(self.x, vy, self.x + self.w, vy)
			y += part.step
	
	void DrawLinX(context c, GridPartition part)
		c.SetLineWidth(0.9)
		c.SetFontSize(7)
		float x = part.min
		while x <= part.max and part.step > 0
			c.SetColor(self.col_grid)
			float vx = self.projectx(x)
			c.DrawLine(vx, self.y, vx, self.y + self.h)
			c.SetColor(self.col_text)
			string t = x.str2(part.decimals)
			t += " "
			t += self.x_unit
			c.DrawStr(vx, self.y + self.h + 5, t)
			if part.factor < 3
				c.SetColor(self.col_grid2)
				vx = self.projectx(x + part.step / 2)
				c.DrawLine(vx, self.y, vx, self.y + self.h)
			x += part.step

	void Draw(context c, float x0, float y0, float w, float h)
	
		y0 += 3
		self.x0 = x0
		self.y0 = y0
		float x = x0 + 40
		float y = y0
		w -= 43
		h -= 23
		self.x = x
		self.y = y
		self.w = w
		self.h = h
		
		
		self.col_grid = color(1, 0.8, 0.8, 0.8)
		self.col_grid2 = color(1, 0.9, 0.9, 0.9)
		self.col_text = color(1, 0.4, 0.4, 0.4)
		self.col_bg = White
		
		// background
		c.SetColor(self.col_bg)
		c.DrawRect(x, y, w, h)
	
		c.SetLineWidth(0.9)
		c.SetFontSize(7)
		if self.x_log
			float ff = self.x_val_min
			while ff <= self.x_val_max
				float fx = self.projectx(ff)
				c.SetColor(self.col_grid)
				c.DrawLine(fx, y, fx, y + h)
				c.SetColor(self.col_text)
				c.DrawStr(fx, y + h + 5, ff.str2(0) + " " + self.x_unit)
				fx = self.projectx(ff * sqrt(2))
				c.SetColor(self.col_grid2)
				c.DrawLine(fx, y, fx, y + h)
				ff *= 2
		else
			GridPartition part = get_lin_partition(self.x_val_min, self.x_val_max, w)
			self.DrawLinX(c, part)
		part = get_lin_partition(self.y_val_min, self.y_val_max, h)
		self.DrawLinY(c, part)
	
	void DrawCurve(context c, FloatInterpolator fi, bool fill_below)
		float tt[], xx[], yy[]
		tt = rangef(0, 1, 0.003)
		yy = fi.get_list(tt)
		for int i, 0, tt.num
			complex zz = self.project2(complex(self.rel2valx(tt[i]), yy[i]))
			yy[i] = zz.y
			xx.add(zz.x)
		if fill_below
			xx.add(self.x + self.w)
			yy.add(self.y + self.h)
			xx.add(self.x)
			yy.add(self.y + self.h)
			c.SetColor(color(0.3, 0.3, 0.3, 1))
			c.DrawPolygon(xx, yy)
			xx.resize(xx.num - 2)
			yy.resize(yy.num - 2)
		c.SetLineWidth(2)
		c.SetColor(Black)
		c.DrawLines(xx, yy)
	
	void DrawCurveB(context c, float x[], float y[], bool fill_below, color col)
		float xx[], yy[]
		for int i, 0, x.num
			complex zz = self.project2(complex(x[i], y[i]))
			yy.add(zz.y)
			xx.add(zz.x)
		if fill_below
			xx.add(self.x + self.w)
			yy.add(self.y + self.h)
			xx.add(self.x)
			yy.add(self.y + self.h)
			color col2 = col
			col2.a = 0.3
			c.SetColor(col2)
			c.DrawPolygon(xx, yy)
			xx.resize(xx.num - 2)
			yy.resize(yy.num - 2)
		c.SetLineWidth(0.9)
		c.SetColor(col)
		c.DrawLines(xx, yy)
	
	void DrawPoint2(context c, complex p, bool selected, bool hover)
		complex pp = self.project2(p)
		c.SetColor(Black)
		float radius = 3
		if hover
			c.SetColor(Red)
			radius = 4
		else if selected
			c.SetColor(color(1, 0.7, 0, 0))
		c.DrawCircle(pp.x, pp.y, radius)
	
	void DrawPoint3(context c, vector p, bool selected, bool hover)
		vector pp = self.project3(p)
		c.SetColor(Black)
		float radius = 3
		if hover
			c.SetColor(Red)
			c.DrawStr(pp.x, pp.y - 20, pp.z.str2(1))
			radius = 4
		else if selected
			c.SetColor(color(1, 0.7, 0, 0))
		c.DrawCircle(pp.x, pp.y, radius)
	
	complex GetMouse2()
		float mx = HuiGetEvent().mouse_x
		float my = HuiGetEvent().mouse_y
		return self.unproject2(complex(mx, my))
	
	vector GetMouse3(float z)
		float mx = HuiGetEvent().mouse_x
		float my = HuiGetEvent().mouse_y
		return self.unproject3(vector(mx, my, z))
		
	bool MouseOverPoint2(complex q)
		float mx = HuiGetEvent().mouse_x
		float my = HuiGetEvent().mouse_y
		complex p = self.project2(q)
		return (mx > p.x - 5) and (mx < p.x + 5) and (my > p.y - 5) and (my < p.y + 5)
		
	bool MouseOverPoint3(vector q)
		return self.MouseOverPoint2(complex(q.x, q.y))
