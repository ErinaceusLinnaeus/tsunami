

float db_to_factor(float db)
	return pow(10, db/20)

float factor_to_db(float f)
	return log(f) / log(10) * 20


class Filter
	float[3] a, b
	float sample_rate
	void apply(float[] x, float[] y, float[2] prev_x, float[2] prev_y)
		// overlap
		y[0] = b[0] * x[0] + b[1] * prev_x[1] + b[2] * prev_x[0] - a[1] * prev_y[1] - a[2] * prev_y[0]
		y[1] = b[0] * x[1] + b[1] * x[0]      + b[2] * prev_x[1] - a[1] * y[0]      - a[2] * prev_y[1]
		// main chunk
		for i in 2:x.num
			y[i] = b[0] * x[i] + b[1] * x[i-1] + b[2] * x[i-2] - a[1] * y[i-1] - a[2] * y[i-2]
	void __init__()
		a[0] = 0
		a[1] = 0
		a[2] = 0
		b[0] = 1
		b[1] = 0
		b[2] = 0
	void __assign__(Filter o)
	float gain(float f)
		complex z
		z.x = cos(2*pi*f/sample_rate)
		z.y = sin(2*pi*f/sample_rate)
		complex H = complex(b[0], 0) + b[1]*z + b[2]*z*z
		complex y = complex(1,0) + a[1]*z + a[2]*z*z
		
		float fac = H.abs() / y.abs()
		return factor_to_db(fac)

	void create_peak(float f_res, float Q, float gain)
		float g = db_to_factor(gain)
		float c = 1 / tan(pi * f_res / sample_rate)
		float B = 1 / Q
		float a0 = c*c + B*c + 1
		b[0] = (c*c + B*c*g + 1) / a0
		a[1] = (2 - 2*c*c) / a0
		b[1] = a[1]
		a[2] = (c*c - B*c + 1) / a0
		b[2] = (c*c - B*g*c + 1) / a0

	void create_notch(float f_res, float Q)
		float c = tan(pi * f_res / sample_rate)
		float a0 = 1 + c/Q + c*c
		b[0] = (1 + c*c) / a0
		b[1] = 2 * (c*c - 1) / a0
		b[2] = b[0]
		a[1] = b[1]
		a[2] = (1 - c/Q + c*c) / a0

	void create_low_pass(float f_res, float q)
		/*b[0] = 1 / (1 + sample_rate/f_res/2/pi)
		b[1] = 0
		b[2] = 0
		a[1] = b[0]-1
		a[2] = 0*/
		q = sqrt(2) //20 / q
		float c = tan(pi * f_res / sample_rate)
		float a0 = 1 + c*q + c*c
		b[0] = c*c / a0
		b[1] = 2 * b[0]
		b[2] = b[0]
		a[1] = 2 * (c*c - 1) / a0
		a[2] = (1 - c*q + c*c) / a0

	void create_high_pass(float f_res, float q)
		/*b[0] = 1 / (1 + f_res*2*pi / sample_rate)
		b[1] = -b[0]
		b[2] = 0
		a[1] = -b[0]
		a[2] = 0*/
		q = sqrt(2) //20 / q
		float c = tan(pi * f_res / sample_rate)
		float a0 = 1 + c*q + c*c
		b[0] = 1 / a0
		b[1] = - 2 * b[0]
		b[2] = b[0]
		a[1] = 2 * (c*c - 1) / a0
		a[2] = (1 - c*q + c*c) / a0

	void create_low_shelf(float f_res, float q, float gain)
		float V = db_to_factor(abs(gain))
		float c = tan(pi * f_res / sample_rate)
		
		if gain > 0
			float a0 = 1 + sqrt(2)*c + c*c
			b[0] = (1 + sqrt(2*V)*c + V*c*c) / a0
			b[1] = 2*(V*c*c - 1) / a0
			b[2] = (1-sqrt(2*V)*c + V*c*c) / a0
			a[1] = 2*(c*c - 1) / a0
			a[2] = (1-sqrt(2)*c + c*c) / a0
		else
			float a0 = 1 + sqrt(2*V)*c + V*c*c
			b[0] = (1 + sqrt(2)*c + c*c) / a0
			b[1] = 2*(c*c - 1) / a0
			b[2] = (1 - sqrt(2)*c + c*c) / a0
			a[1] = 2*(V*c*c - 1) / a0
			a[2] = (1 - sqrt(2*V)*c + V*c*c) / a0
		
		/*float c = 2 * sample_rate//1 / tan(pi * f_res / sample_rate)
		float w = 2*pi*f_res
		float ww = w * (B+1)
		float a0 = w+ww
		b[0] = (c+ww) / a0
		b[1] = (ww-c) / a0
		b[2] = 0
		a[1] = (w-c) / a0
		a[2] = 0*/

	void create_high_shelf(float f_res, float q, float gain)
		float V = db_to_factor(abs(gain))
		float c = tan(pi * f_res / sample_rate)
		
		if gain > 0
			float a0 = 1 + sqrt(2)*c + c*c
			b[0] = (V + sqrt(2*V)*c + c*c) / a0
			b[1] = 2*(c*c - V) / a0
			b[2] = (V - sqrt(2*V)*c + c*c) / a0
			a[1] = 2*(c*c - 1) / a0
			a[2] = (1 - sqrt(2)*c + c*c) / a0
		else
			float a0 = V + sqrt(2*V)*c + c*c
			b[0] = (1 + sqrt(2)*c + c*c) / a0
			b[1] = 2*(c*c - 1) / a0
			b[2] = (1 - sqrt(2)*c + c*c) / a0
			a[1] = 2*(c*c - V) / a0
			a[2] = (V - sqrt(2*V)*c + c*c) / a0
