use tsunami.*
use hui

struct Pitch
	var pitch: int
	var active: bool[]
	func is_active(i: int) -> bool
		if i < 0 or i >= len(active)
			return false
		return active[i]

class Config extends Module.Config
	var beats: int
	var subbeats: int
	var pitches: Pitch[]
	
	func override reset()
		beats = 4
		subbeats = 4
		pitches = [[64,[true,false,true]], [66,[false,true]], [67,[]], [69,[]], [71,[]]]

class SequencerSource extends MidiSource
	var in_beats: Module.InPort

	var config: Config
	var cur_beat = 0
	var fraction: float? # output
	
	func override __init__()
		super.__init__()
		in_beats._init_beats(&self, "in")
	
	func override on_config()
		#subbeat_length = DEFAULT_SAMPLE_RATE * 60 / config.bpm / config.subbeats

	func override reset_state()
		cur_beat = 0
		fraction = nil
		
	func override read(out midi: MidiEventBuffer) -> int
		var beats: Beat[]
		for s in in_beats.source
			let rr = s.read_beats(beats, midi.samples)
		
		var buf: MidiEventBuffer
		for b in beats
			if b.level >= 2
				continue
			let beat_length = b.range.length
			let subbeat_length = beat_length / config.subbeats
			
			for s in 0:config.subbeats
				let subbeat_index = cur_beat * config.subbeats + s
				for p in config.pitches
					if p.is_active(subbeat_index)
						buf.add(MidiEvent(b.range.offset + s * subbeat_length, p.pitch, 1))
						buf.add(MidiEvent(b.range.offset + (s+1) * subbeat_length - 1, p.pitch, 0))
			if b.range.end() < midi.samples
				cur_beat = loop(cur_beat + 1, 0, config.beats)
		
			fraction = (float(cur_beat) + float(midi.samples - b.range.offset) / b.range.length) / config.beats
				
		for e in buf
			if e.pos >= 0 and e.pos < midi.samples
				midi.add(e)
			
		return midi.samples
	
	func override create_panel() -> xfer[ConfigPanel]
		return new SequencerPanel(self)


class SequencerPanel extends ConfigPanel
	var override c: SequencerSource&
	var hover: (int,int)?
	var width = 0
	var height = 0
	var id_runner = -1
	
	func override __init__(_h: Module)
		from_source("
Grid ? '' vertical
	Grid ? ''
		Label l-beats 'Beats'
		SpinButton beats '4' range=1:32 'tooltip=Number of beats' expandx
		Label l-beats '/'
		SpinButton subbeats '4' range=1:32 'tooltip=Number of beat divisions' expandx
	DrawingArea drawing '' grabfocus expandx expandy")
	
		event("beats", on_edit)
		event("subbeats", on_edit)
		event_x("drawing", "hui:draw", on_draw)
		event_x("drawing", "hui:left-button-down", on_left_button_down)
		event_x("drawing", "hui:mouse-move", on_mouse_move)
		event_x("drawing", "hui:mouse-leave", on_mouse_leave)
		
		id_runner = hui.run_repeated(0.02, trigger_redraw)
	
	func override __delete__()
		hui.cancel_runner(id_runner)
	
	func get_hover() -> (int,int)?
		let subbeats = c.config.beats*c.config.subbeats
		let m = hui.get_event().mouse
		let k = int((height - m.y) / (height / len(c.config.pitches)))
		let i = int(m.x / (width / subbeats))
		if k>=0 and k<len(c.config.pitches) and i>=0 and i<subbeats
			return (k,i)
		return nil
	
	func mut on_left_button_down()
		hover = get_hover()
		for h in hover
			c.config.pitches[h[0]].active.resize(c.config.beats*c.config.subbeats)
			c.config.pitches[h[0]].active[h[1]] = not c.config.pitches[h[0]].active[h[1]]
			changed()
		redraw("drawing")

	func mut on_mouse_move()
		hover = get_hover()
		redraw("drawing")

	func mut on_mouse_leave()
		hover = nil
		redraw("drawing")
	
	func mut on_draw(p: hui.Painter)
		width = p.width
		height = p.height
		
		p.set_color(theme.background)
		p.draw_rect([0,width, 0,height])
		
		let subbeats = c.config.beats*c.config.subbeats
		var active = -1
		for f in c.fraction
			active = int(subbeats * f)
		let gridx = float(width) / subbeats
		let gridy = float(height) / len(c.config.pitches)
		let border = gridx * 0.05
		let beat_border = gridx * 0.07 # additional
		let wbutton = (width - subbeats * border - (c.config.beats-1)*beat_border) / subbeats
		
		for k=>pitch in c.config.pitches
			let col0 = theme.pitch_color(pitch.pitch)
			var x0 = border
			for i in 0:subbeats
				var col = color.interpolate(col0, theme.background, 0.4)
				if i == active
					col = col0
				if not pitch.is_active(i)
					col = color.interpolate(col0, theme.background, 0.92)
				for h in hover
					if k == h[0] and i == h[1]
						col = theme.hoverify(col)
				p.set_color(col)
				p.draw_rect([x0, x0+wbutton, height-k*gridy-border, height-(k+1)*gridy+border])
				x0 += wbutton + border
				if ((i+1) % c.config.subbeats) == 0
					x0 += beat_border
		
		for f in c.fraction
			p.set_color(color.GREEN)
			let x = float(width) * f
			p.draw_line([x,0], [x,height])
	
	func mut on_edit()
		c.config.beats = get_int("beats")
		c.config.subbeats = get_int("subbeats")
		changed()
		redraw("drawing")
	
	func override update()
		set_int("beats", c.config.beats)
		set_int("subbeats", c.config.subbeats)
		redraw("drawing")
	
	func mut trigger_redraw()
		redraw("drawing")




